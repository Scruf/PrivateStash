"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.getResolvedPublishConfig = exports.Publisher = undefined;

var _bluebirdLstC;

function _load_bluebirdLstC() {
    return _bluebirdLstC = require("bluebird-lst-c");
}

let getResolvedPublishConfig = exports.getResolvedPublishConfig = (() => {
    var _ref = (0, (_bluebirdLstC || _load_bluebirdLstC()).coroutine)(function* (packager, publishConfig, errorIfCannot) {
        let getInfo = (() => {
            var _ref2 = (0, (_bluebirdLstC || _load_bluebirdLstC()).coroutine)(function* () {
                const info = yield packager.repositoryInfo;
                if (info != null) {
                    return info;
                }
                if (!errorIfCannot) {
                    return null;
                }
                (0, (_log || _load_log()).warn)("Cannot detect repository by .git/config");
                throw new Error(`Please specify "repository" in the dev package.json ('${ packager.devPackageFile }').\nPlease see https://github.com/electron-userland/electron-builder/wiki/Publishing-Artifacts`);
            });

            return function getInfo() {
                return _ref2.apply(this, arguments);
            };
        })();

        if (publishConfig.provider === "generic") {
            if (publishConfig.url == null) {
                throw new Error(`Please specify "url" for "generic" update server`);
            }
            return publishConfig;
        }

        let owner = publishConfig.owner;
        let project = publishConfig.provider === "github" ? publishConfig.repo : publishConfig.package;
        if (!owner || !project) {
            const info = yield getInfo();
            if (info == null) {
                return null;
            }
            if (!owner) {
                owner = info.user;
            }
            if (!project) {
                project = info.project;
            }
        }
        const copy = Object.assign({}, publishConfig);
        if (copy.owner == null) {
            copy.owner = owner;
        }
        if (publishConfig.provider === "github") {
            const options = copy;
            if (options.repo == null) {
                options.repo = project;
            }
            return options;
        } else if (publishConfig.provider === "bintray") {
            const options = copy;
            if (options.package == null) {
                options.package = project;
            }
            return options;
        } else {
            return null;
        }
    });

    return function getResolvedPublishConfig(_x, _x2, _x3) {
        return _ref.apply(this, arguments);
    };
})();

exports.computeDownloadUrl = computeDownloadUrl;

var _uploader;

function _load_uploader() {
    return _uploader = require("./uploader");
}

var _fsExtraP;

function _load_fsExtraP() {
    return _fsExtraP = require("fs-extra-p");
}

var _path = _interopRequireWildcard(require("path"));

var _path2 = require("path");

var _log;

function _load_log() {
    return _log = require("electron-builder-util/out/log");
}

var _url;

function _load_url() {
    return _url = _interopRequireWildcard(require("url"));
}

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

class Publisher {
    upload(file, artifactName) {
        var _this = this;

        return (0, (_bluebirdLstC || _load_bluebirdLstC()).coroutine)(function* () {
            const fileName = artifactName || (0, _path2.basename)(file);
            const fileStat = yield (0, (_fsExtraP || _load_fsExtraP()).stat)(file);
            yield _this.doUpload(fileName, fileStat.size, (_uploader || _load_uploader()).uploadFile.bind(_this, file, fileStat, fileName));
        })();
    }
    uploadData(data, fileName) {
        if (data == null || fileName == null) {
            throw new Error("data or fileName is null");
        }
        return this.doUpload(fileName, data.length, it => it.end(data));
    }
}
exports.Publisher = Publisher;
function computeDownloadUrl(publishConfig, fileName, version) {
    if (publishConfig.provider === "generic") {
        const baseUrl = (_url || _load_url()).parse(publishConfig.url);
        return (_url || _load_url()).format(Object.assign({}, baseUrl, { pathname: _path.posix.resolve(baseUrl.pathname || "/", fileName) }));
    } else {
        const gh = publishConfig;
        return `https://github.com${ `/${ gh.owner }/${ gh.repo }/releases` }/download/v${ version }/${ fileName }`;
    }
}
//# sourceMappingURL=publisher.js.map